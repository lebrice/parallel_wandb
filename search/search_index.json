{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"parallel_wandb","text":"<p>This simple package makes it easy to use the new (<code>reinit=\"create_new\"</code>) feature of Weights &amp; Biases (wandb) to create and log to multiple wandb runs in parallel</p> <p>This, when combined with <code>jax.vmap</code>, enables extremely efficient, high-throughput training (and logging!) of multiple simultaneous training runs.</p> <ul> <li>This package provides two simple functions that you can import and use in your own project: <code>wandb_init</code> to initialize multiple wandb runs and <code>wandb_log</code> to log metrics to them in parallel.</li> <li>A demonstration of how these can be used with jax.vmap can be found in <code>jax_mnist.py</code>. A demonstration of this can be found in <code>jax_mnist.py</code>.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li> <p>(optional) Install UV: https://docs.astral.sh/uv/getting-started/installation/</p> </li> <li> <p>Add this package as a dependency to your project:</p> </li> </ol> <pre><code>uv add parallel_wandb\n</code></pre> <p>OR, if you don't use UV yet, you can also <code>pip install parallel_wandb</code>.</p>"},{"location":"#usage","title":"Usage","text":"<pre><code>from parallel_wandb import wandb_init, wandb_log\n\nruns = wandb_init(\n    {\"name\": [\"run_0\", \"run_1\"], \"config\": {\"seed\": [0, 1]}},\n    project=\"test_project\",\n    name=\"test_name\",\n)\nassert isinstance(runs, np.ndarray) and runs.shape == (2,) and runs.dtype == object\n\nwandb_log(runs, {\"loss\": [0.1, 0.2]}, step=0)\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>Lightweight library to facilitate logging to multiple Weights &amp; Biases runs in parallel.</p>"},{"location":"reference/#parallel_wandb.wandb_init","title":"wandb_init","text":"<pre><code>wandb_init(\n    stacked_overrides: (\n        NestedMapping[str, ArrayLike] | None\n    ) = None,\n    process_index: int | None = None,\n    _wandb_init: Callable[P, Run] = init,\n    *args: args,\n    **kwargs: kwargs\n) -&gt; NestedSequence[Run]\n</code></pre> <p>Initializes multiple wandb runs in parallel.</p> <p>The usual args and kwargs to be passed to wandb.init will be overwritten by the (unstacked) values in <code>stacked_overrides</code>. The values in <code>stacked_overrides</code> should be lists or arrays with the same shape. The shape of the first item in that dict determines the shape of the runs to be created. The stacked arguments are to be passed separately and will override the values from args and *kwargs.</p> <p>For example:</p> <pre><code>wandb_init({\"name\": [\"run_1\", \"run_2\", \"run_3\"], \"config\": {\"seed\": [1, 2, 3]}})\n# This will create three runs like so:\nnp.asarray([\n    wandb.init(name=\"run_1\", config={\"seed\": 1}, reinit=\"create_new\"),\n    wandb.init(name=\"run_2\", config={\"seed\": 2}, reinit=\"create_new\"),\n    wandb.init(name=\"run_3\", config={\"seed\": 3}, reinit=\"create_new\"),\n])\n</code></pre> <p>This also works with nested arrays:</p> <pre><code>wandb_init({\"name\": [[\"run_1\", \"run_2\"], [\"run_3\", \"run_4]], \"config\": {\"seed\": [[1, 2], [3, 4]]}})\n# This will create four runs like so:\nnp.asarray([\n    [\n        wandb.init(name=\"run_1\", config={\"seed\": 1}, reinit=\"create_new\"),\n        wandb.init(name=\"run_2\", config={\"seed\": 2}, reinit=\"create_new\"),\n    ],\n    [\n        wandb.init(name=\"run_3\", config={\"seed\": 3}, reinit=\"create_new\"),\n        wandb.init(name=\"run_4\", config={\"seed\": 4}, reinit=\"create_new\"),\n    ]\n])\n</code></pre>"},{"location":"reference/#parallel_wandb.map_fn_foreach_run","title":"map_fn_foreach_run","text":"<pre><code>map_fn_foreach_run(\n    wandb_run: Run | NestedSequence[Run],\n    fn: Callable[\n        Concatenate[LogContext, P], dict[str, Any] | None\n    ],\n    step: int | ArrayLike,\n    run_index: NDArray[integer] | ArrayLike | None = None,\n    *args: args,\n    **kwargs: kwargs\n)\n</code></pre> <p>Map a function over the sliced arg and kwargs for each run and log the results to wandb.</p> <p>This is meant to be used to log things like wandb tables, images and such, that need to be created with the data of each run.</p> <p>In the case of Jax, this function will executed inside a <code>jax.experimental.io_callback</code>.</p> <p><code>fn</code> should be a function that takes a <code>LogContext</code> as first argument. This is dataclass that contains the run, run index, number of runs, and current step. The function should can either return a dictionary of things to log to wandb or do the logging directly using the context's <code>run</code> attribute.</p> <ul> <li>If <code>wandb_run</code> is a single run, the function will be called with the args   and kwargs unchanged.</li> <li>If <code>wandb_run</code> is an array of runs, the function will be called with the   sliced args and kwargs for each run.</li> </ul> <p>Arguments:     wandb_run: Wandb run or ndarray of Wandb runs. Can have more than one dimension.     fn: Function to call with the context and sliced args and kwargs.     step: The current step. Can either be an int or an array of the same shape as the runs array.     run_index: Array of the same shape as <code>wandb_run</code> that needs to be passed if this is to be vmapped.     args: The positional arguments to the function.     kwargs: The keyword arguments to the function.</p>"},{"location":"reference/#parallel_wandb.map_fn_foreach_run--example","title":"Example","text":"<pre><code>import wandb\nfrom parallel_wandb import wandb_init, map_fn_foreach_run\nimport numpy as np\n\nseeds = np.arange(5)\nruns = wandb_init(\n    {\"config\": {\"seed\": seeds}},\n    project=\"test_project\",\n    group=\"testing\",\n)\n# some data for each run\nimages = np.stack(\n    [np.random.default_rng(seed).uniform(0, 255, (32, 32, 3)).astype(np.uint8) for seed in seeds]\n)\n# Create a wandb.Image with the data for each run:\nstep = 0\nmap_fn_foreach_run(\n    runs,\n    lambda ctx, image: {\"train_samples\": wandb.Image(image)},\n    step=step,\n    image=images,\n)\n</code></pre>"},{"location":"reference/#parallel_wandb.wandb_log","title":"wandb_log","text":"<pre><code>wandb_log(\n    wandb_run: Run | NestedSequence[Run],\n    metrics: dict[str, Any],\n    step: int | NDArray[integer] | ArrayLike,\n    run_index: NDArray[integer] | ArrayLike | None = None,\n    same_metrics_for_all_runs: bool | None = None,\n)\n</code></pre> <p>Log metrics to wandb using <code>wandb.log</code> for each run in <code>wandb_run</code>.</p> <p>If <code>log_metric_to_all_runs</code> is False, the metrics are logged to every run.</p>"}]}